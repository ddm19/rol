<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>PDF Viewer</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="stylesheet" href="./web/pdf_viewer.css" />
    <style>
      :root {
        --bg-primary: #fff1d7;
        --bg-secondary: #fff1d7;
        --colors-darkRed: #5e0202;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: var(--bg-primary);
      }
      #container {
        position: fixed;
        inset: 0;
        overflow: auto;
        background: var(--bg-secondary);
        scrollbar-width: thin;
        scrollbar-color: var(--colors-darkRed) transparent;
      }
      #container::-webkit-scrollbar {
        width: 8px;
      }
      #container::-webkit-scrollbar-track {
        background: var(--bg-secondary);
      }
      #container::-webkit-scrollbar-thumb {
        background-color: var(--colors-darkRed);
        border-radius: 4px;
      }
      #viewer.pdfViewer {
        padding: 16px;
      }
      .loadingMask {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(17, 17, 17, 0.98);
        color: #fff;
        z-index: 9999;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Arial,
          sans-serif;
        flex-direction: column;
        gap: 12px;
      }
      .loadingMask__spinner {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border: 3px solid rgba(255, 255, 255, 0.2);
        border-top-color: #fff;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .loadingMask__text {
        opacity: 0.85;
        font-size: 14px;
      }
      @media print {
        html,
        body {
          height: auto;
          background: transparent !important;
        }
        #container {
          position: static !important;
          inset: auto !important;
          overflow: visible !important;
          height: auto !important;
          background: transparent !important;
        }
        #viewer.pdfViewer {
          padding: 0 !important;
        }
        .loadingMask {
          display: none !important;
        }
        .pdfViewer .page {
          break-inside: avoid;
          page-break-inside: avoid;
          break-after: page;
          page-break-after: always;
          transform: none !important;
          transform-origin: initial !important;
        }
        @page {
          size: A4;
          margin: 0;
        }
      }
    </style>
  </head>
  <body>
    <div id="container"><div id="viewer" class="pdfViewer"></div></div>

    <div id="loadingMask" class="loadingMask" aria-live="polite">
      <div class="loadingMask__spinner"></div>
      <div id="loadingOverlay">
        <div id="loadingBox">
          <h2>Cargando ficha…</h2>
          <div class="spinner" aria-hidden="true"></div>
          <p>Hay un kobold escribiendo tu ficha a mano.</p>
          <div id="loadingHint">Si tarda mucho, lo sustituiremos por otro.</div>
        </div>
      </div>
    </div>

    <script>
      window.__earlyQueue = [];
      window.addEventListener("message", (e) => {
        window.__earlyQueue.push(e.data);
      });
    </script>
    <script></script>

    <script type="module">
      import * as pdfjsLib from "./build/pdf.mjs";
      import { PDFViewer, EventBus } from "./web/pdf_viewer.mjs";

      pdfjsLib.GlobalWorkerOptions.workerSrc = "./build/pdf.worker.mjs";

      const params = new URLSearchParams(location.search);
      const url = params.get("file");
      if (!url) {
        document.body.innerHTML =
          '<p style="color:white;padding:16px">Falta el parámetro ?file=</p>';
        throw new Error("Missing file param");
      }

      const MAX_WAIT_MS = 7000;
      const FIXED_DELAY_MS = 3500;
      const loadingMask = document.getElementById("loadingMask");
      let valuesAppliedOnce = false;
      let maskRemoved = false;
      const removeMask = () => {
        if (maskRemoved) return;
        maskRemoved = true;
        loadingMask?.remove();
      };

      function delayedRemoveMask() {
        if (maskRemoved) return;
        setTimeout(() => removeMask(), FIXED_DELAY_MS);
      }

      setTimeout(() => {
        if (!valuesAppliedOnce) removeMask();
      }, MAX_WAIT_MS);

      const eventBus = new EventBus();
      const container = document.getElementById("container");
      const viewer = new PDFViewer({
        container,
        eventBus,
        annotationMode: pdfjsLib.AnnotationMode.ENABLE_FORMS,
        textLayerMode: 2,
      });

      let pendingValues = null;
      let readyForData = false;

      function inputsReady() {
        return (
          !!document.querySelector('input[name="CharacterName"]') ||
          document.querySelector("input, textarea, select")
        );
      }
      function deferUntilInputsReady(fn, tries = 80) {
        if (inputsReady()) {
          fn();
          return;
        }
        if (tries <= 0) {
          fn();
          return;
        }
        setTimeout(() => deferUntilInputsReady(fn, tries - 1), 100);
      }

      function applyPdfFormValues(values, root) {
        const scope = root || document.getElementById("container");
        const fields = scope.querySelectorAll("input, textarea, select");
        const byName = {};
        fields.forEach((el) => {
          const key =
            el.name ||
            el.getAttribute("data-annotation-id") ||
            el.getAttribute("aria-label") ||
            el.getAttribute("title");
          if (key) byName[key] = el;
        });
        for (const [k, v] of Object.entries(values)) {
          const el = byName[k];
          if (!el) continue;
          if (el.type === "checkbox") el.checked = !!v;
          else el.value = v ?? "";
          el.dispatchEvent(new Event("input", { bubbles: true }));
          el.dispatchEvent(new Event("change", { bubbles: true }));
        }
      }

      function collectPdfFormValues() {
        const root = document.getElementById("container");
        const fields = root.querySelectorAll("input, textarea, select");
        const out = {};
        fields.forEach((el) => {
          const key =
            el.name ||
            el.getAttribute("data-annotation-id") ||
            el.getAttribute("aria-label") ||
            el.getAttribute("title");
          if (!key) return;
          if (el.type === "checkbox") out[key] = !!el.checked;
          else out[key] = el.value || "";
        });
        return out;
      }

      function warmupPages() {
        const c = document.getElementById("container");
        const y = c.scrollTop;
        c.scrollTop = c.scrollHeight;
        setTimeout(() => {
          c.scrollTop = 0;
        }, 50);
        setTimeout(() => {
          c.scrollTop = y;
        }, 100);
      }

      function postReady() {
        if (readyForData) return;
        readyForData = true;
        try {
          window.parent?.postMessage({ type: "VIEWER_READY" }, "*");
        } catch {}
        try {
          const q = window.__earlyQueue || [];
          q.forEach((d) => handleIncoming(d));
          window.__earlyQueue = [];
        } catch {}
      }

      eventBus.on("annotationlayerrendered", (evt) => {
        ensureCalculatedFieldsVisible();
        attachRecomputeListeners();
        setTimeout(() => {
          ensureCalculatedFieldsVisible();
          recompute();
        }, 0);
        if (pendingValues) {
          const root =
            evt?.source?.div || evt?.source?.annotationLayer?.div || undefined;
          applyPdfFormValues(pendingValues, root);
        }
        postReady();
      });

      const loadingTask = pdfjsLib.getDocument({
        url,
        cMapUrl: "./cmaps/",
        cMapPacked: true,
      });
      const pdf = await loadingTask.promise;
      viewer.setDocument(pdf);

      container.addEventListener("pagesinit", () => {
        viewer.currentScaleValue = "page-width";
        setTimeout(() => {
          ensureCalculatedFieldsVisible();
          attachRecomputeListeners();
          recompute();
        }, 250);
        postReady();
      });

      function handleIncoming(data) {
        if (!data || typeof data.type !== "string") return;
        switch (data.type) {
          case "ZOOM_IN":
            viewer.currentScale *= 1.1;
            break;
          case "ZOOM_OUT":
            viewer.currentScale /= 1.1;
            break;
          case "FIT_WIDTH":
            viewer.currentScaleValue = "page-width";
            break;
          case "FIT_PAGE":
            viewer.currentScaleValue = "page-fit";
            break;
          case "PRINT_PDF":
            (async () => {
              try {
                const values = collectPdfFormValues();
                let originalBytes;
                try {
                  const data = await pdf.getData();
                  originalBytes =
                    data instanceof Uint8Array ? data : new Uint8Array(data);
                } catch {
                  const res = await fetch(url, { credentials: "include" });
                  if (!res.ok) throw new Error(`HTTP ${res.status}`);
                  originalBytes = new Uint8Array(await res.arrayBuffer());
                }
                let PDFDocument, PDFName, PDFBool;
                try {
                  const mod = await import(
                    "https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/+esm"
                  );
                  PDFDocument = mod.PDFDocument;
                  PDFName = mod.PDFName;
                  PDFBool = mod.PDFBool;
                } catch {
                  await new Promise((resolve, reject) => {
                    const s = document.createElement("script");
                    s.src =
                      "https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js";
                    s.onload = resolve;
                    s.onerror = reject;
                    document.head.appendChild(s);
                  });
                  const mod = window.PDFLib;
                  PDFDocument = mod.PDFDocument;
                  PDFName = mod.PDFName;
                  PDFBool = mod.PDFBool;
                }
                const pdfDoc = await PDFDocument.load(originalBytes, {
                  updateMetadata: false,
                  ignoreEncryption: true,
                });
                const form = pdfDoc.getForm();
                for (const [k, v] of Object.entries(values)) {
                  let field;
                  try {
                    field = form.getField(k);
                  } catch {}
                  if (!field) continue;
                  const t = field.constructor.name;
                  if (t === "PDFTextField") field.setText(String(v ?? ""));
                  else if (t === "PDFCheckBox")
                    v ? field.check() : field.uncheck();
                  else if (t === "PDFDropdown") {
                    try {
                      field.select(String(v));
                    } catch {
                      field.setText(String(v ?? ""));
                    }
                  } else if (t === "PDFOptionList") {
                    try {
                      field.select(String(v));
                    } catch {}
                  } else if (t === "PDFRadioGroup") {
                    try {
                      field.select(String(v));
                    } catch {}
                  } else {
                    try {
                      field.setText(String(v ?? ""));
                    } catch {}
                  }
                }
                try {
                  const acroFormRef = pdfDoc.catalog.get(
                    PDFName.of("AcroForm"),
                  );
                  if (acroFormRef) {
                    const acroForm = pdfDoc.context.lookup(acroFormRef);
                    acroForm.set(PDFName.of("NeedAppearances"), PDFBool.True);
                  }
                } catch {}
                const out = await pdfDoc.save({
                  addDefaultPage: false,
                  useObjectStreams: true,
                });
                const blob = new Blob([out], { type: "application/pdf" });
                const urlFilled = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = urlFilled;
                a.download = values.CharacterName
                  ? `Ficha_${values.CharacterName.replace(/[\/\\?%*:|"<>]/g, "_")}.pdf`
                  : "Ficha.pdf";
                document.body.appendChild(a);
                a.click();
                a.remove();
                setTimeout(() => URL.revokeObjectURL(urlFilled), 4000);
              } catch (ex) {
                console.error(ex);
                window.print();
              }
            })();
            break;
          case "SET_PDF_FIELDS":
            deferUntilInputsReady(() => {
              pendingValues = data.values || {};
              applyPdfFormValues(pendingValues);
              ensureCalculatedFieldsVisible();
              attachRecomputeListeners();
              recompute();
              valuesAppliedOnce = true;
              delayedRemoveMask();
              warmupPages();
            });
            break;
        }
      }

      window.addEventListener("message", (e) => handleIncoming(e.data));

      window.addEventListener("message", (ev) => {
        if (!ev.data || ev.data.type !== "GET_PDF_FIELDS") return;
        const values = collectPdfFormValues();
        ev.source?.postMessage({ type: "PDF_FIELDS", values }, ev.origin);
      });

      function parseIntSafe(v) {
        if (v === null || v === undefined) return NaN;
        const s = String(v).trim();
        const m = s.match(/^[+\-]?\d+/);
        return m ? parseInt(m[0], 10) : NaN;
      }
      function abilityMod(scoreVal) {
        const n = parseIntSafe(scoreVal);
        if (Number.isNaN(n)) return null;
        return Math.floor((n - 10) / 2);
      }
      function formatSigned(n) {
        if (n === null || n === undefined || Number.isNaN(n)) return "";
        return n >= 0 ? `+${n}` : `${n}`;
      }
      function getEl(name) {
        return document.querySelector(`[name="${CSS.escape(name)}"]`);
      }
      function getValue(name) {
        const el = getEl(name);
        if (!el) return "";
        return el.type === "checkbox" ? (el.checked ? "Yes" : "") : el.value;
      }
      function getChecked(name) {
        const el = getEl(name);
        return !!(el && el.type === "checkbox" && el.checked);
      }
      function setValue(name, val) {
        const el = getEl(name);
        if (!el) return;
        el.value =
          val === "" || val === null || val === undefined ? "" : String(val);
      }
      function ensureVisible(name) {
        const el = getEl(name);
        if (!el) return;
        el.hidden = false;
        el.disabled = false;
        el.removeAttribute("hidden");
        el.style.display = "block";
        el.style.visibility = "visible";
        el.readOnly = false;
      }

      const abilityBonusFields = [
        "STRbonus",
        "DEXbonus",
        "CONbonus",
        "INTbonus",
        "WISbonus",
        "CHAbonus",
      ];
      const saveTotalFields = [
        "STRsave",
        "DEXsave",
        "CONsave",
        "INTsave",
        "WISsave",
        "CHAsave",
      ];
      const skillOutFields = [
        "Acrobatics",
        "Athletics",
        "Deception",
        "History",
        "Performance",
        "Intimidation",
        "Investigation",
        "SleightofHand",
        "Arcana",
        "Medicine",
        "Nature",
        "Perception",
        "Insight",
        "Persuasion",
        "Religion",
        "Stealth",
        "Survival",
        "AnHan",
      ];

      function ensureCalculatedFieldsVisible() {
        [
          ...abilityBonusFields,
          ...saveTotalFields,
          ...skillOutFields,
          "PWP",
        ].forEach(ensureVisible);
      }

      function attachRecomputeListeners() {
        const namesToWatch = [
          "STRscore",
          "DEXscore",
          "CONscore",
          "INTscore",
          "WISscore",
          "CHAscore",
          "ProfBonus",
          "STRsavePROF",
          "DEXsavePROF",
          "CONsavePROF",
          "INTsavePROF",
          "WISsavePROF",
          "CHAsavePROF",
          "acroPROF",
          "athPROF",
          "decepPROF",
          "histPROF",
          "perfPROF",
          "intimPROF",
          "investPROF",
          "sohPROF",
          "arcanaPROF",
          "medPROF",
          "naturePROF",
          "perPROF",
          "insightPROF",
          "persPROF",
          "religPROF",
          "stealthPROF",
          "survPROF",
          "anhanPROF",
        ];
        const sel = namesToWatch
          .map((n) => `[name="${CSS.escape(n)}"]`)
          .join(",");
        document.querySelectorAll(sel).forEach((el) => {
          if (el.__recomputeHooked) return;
          el.addEventListener("input", recompute, { passive: true });
          el.addEventListener("change", recompute, { passive: true });
          el.__recomputeHooked = true;
        });
      }

      function recompute() {
        ensureCalculatedFieldsVisible();
        const mods = {
          STR: abilityMod(getValue("STRscore")),
          DEX: abilityMod(getValue("DEXscore")),
          CON: abilityMod(getValue("CONscore")),
          INT: abilityMod(getValue("INTscore")),
          WIS: abilityMod(getValue("WISscore")),
          CHA: abilityMod(getValue("CHAscore")),
        };
        setValue("STRbonus", formatSigned(mods.STR ?? ""));
        setValue("DEXbonus", formatSigned(mods.DEX ?? ""));
        setValue("CONbonus", formatSigned(mods.CON ?? ""));
        setValue("INTbonus", formatSigned(mods.INT ?? ""));
        setValue("WISbonus", formatSigned(mods.WIS ?? ""));
        setValue("CHAbonus", formatSigned(mods.CHA ?? ""));
        const profBonus = parseIntSafe(getValue("ProfBonus")) || 0;
        [
          { out: "STRsave", mod: mods.STR, profBox: "STRsavePROF" },
          { out: "DEXsave", mod: mods.DEX, profBox: "DEXsavePROF" },
          { out: "CONsave", mod: mods.CON, profBox: "CONsavePROF" },
          { out: "INTsave", mod: mods.INT, profBox: "INTsavePROF" },
          { out: "WISsave", mod: mods.WIS, profBox: "WISsavePROF" },
          { out: "CHAsave", mod: mods.CHA, profBox: "CHAsavePROF" },
        ].forEach(({ out, mod, profBox }) => {
          if (mod === null) {
            setValue(out, "");
            return;
          }
          const total = mod + (getChecked(profBox) ? profBonus : 0);
          setValue(out, formatSigned(total));
        });
        const skillDefs = {
          Acrobatics: { mod: "DEX", prof: "acroPROF" },
          Athletics: { mod: "STR", prof: "athPROF" },
          Deception: { mod: "CHA", prof: "decepPROF" },
          History: { mod: "INT", prof: "histPROF" },
          Performance: { mod: "CHA", prof: "perfPROF" },
          Intimidation: { mod: "CHA", prof: "intimPROF" },
          Investigation: { mod: "INT", prof: "investPROF" },
          SleightofHand: { mod: "DEX", prof: "sohPROF" },
          Arcana: { mod: "INT", prof: "arcanaPROF" },
          Medicine: { mod: "WIS", prof: "medPROF" },
          Nature: { mod: "INT", prof: "naturePROF" },
          Perception: { mod: "WIS", prof: "perPROF" },
          Insight: { mod: "WIS", prof: "insightPROF" },
          Persuasion: { mod: "CHA", prof: "persPROF" },
          Religion: { mod: "INT", prof: "religPROF" },
          Stealth: { mod: "DEX", prof: "stealthPROF" },
          Survival: { mod: "WIS", prof: "survPROF" },
          AnHan: { mod: "WIS", prof: "anhanPROF" },
        };
        Object.entries(skillDefs).forEach(([out, { mod, prof }]) => {
          const m = mods[mod];
          if (m === null) {
            setValue(out, "");
            return;
          }
          const total = m + (getChecked(prof) ? profBonus : 0);
          setValue(out, formatSigned(total));
        });
        if (mods.WIS !== null) {
          const passive =
            10 + mods.WIS + (getChecked("perPROF") ? profBonus : 0);
          setValue("PWP", String(passive));
        } else {
          setValue("PWP", "");
        }
      }
    </script>
  </body>
</html>
