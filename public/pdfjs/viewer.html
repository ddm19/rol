<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>PDF Viewer</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="stylesheet" href="./web/pdf_viewer.css" />
    <style>
      :root {
        --bg-primary: #fff1d7;
        --bg-secondary: #fff1d7;
        --colors-darkRed: #5e0202;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: var(--bg-primary);
      }
      #container {
        position: fixed;
        inset: 0;
        overflow: auto;
        background: var(--bg-secondary);
        scrollbar-width: thin;
        scrollbar-color: var(--colors-darkRed) transparent;
      }
      #container::-webkit-scrollbar {
        width: 8px;
      }
      #container::-webkit-scrollbar-track {
        background: var(--bg-secondary);
      }
      #container::-webkit-scrollbar-thumb {
        background-color: var(--colors-darkRed);
        border-radius: 4px;
      }
      #viewer.pdfViewer {
        padding: 16px;
      }
      .loadingMask {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(17, 17, 17, 0.98);
        color: #fff;
        z-index: 9999;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Arial,
          sans-serif;
        flex-direction: column;
        gap: 12px;
      }
      .loadingMask__spinner {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border: 3px solid rgba(255, 255, 255, 0.2);
        border-top-color: #fff;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .loadingMask__text {
        opacity: 0.85;
        font-size: 14px;
      }
      @media print {
        html,
        body {
          height: auto;
          background: transparent !important;
        }
        #container {
          position: static !important;
          inset: auto !important;
          overflow: visible !important;
          height: auto !important;
          background: transparent !important;
        }
        #viewer.pdfViewer {
          padding: 0 !important;
        }
        .loadingMask {
          display: none !important;
        }
        .pdfViewer .page {
          break-inside: avoid;
          page-break-inside: avoid;
          break-after: page;
          page-break-after: always;
          transform: none !important;
          transform-origin: initial !important;
        }
        @page {
          size: A4;
          margin: 0;
        }
      }
    </style>
  </head>
  <body>
    <div id="container"><div id="viewer" class="pdfViewer"></div></div>

    <div id="loadingMask" class="loadingMask" aria-live="polite">
      <div class="loadingMask__spinner"></div>
      <div id="loadingOverlay">
        <div id="loadingBox">
          <h2>Cargando ficha…</h2>
          <div class="spinner" aria-hidden="true"></div>
          <p>Hay un kobold escribiendo tu ficha a mano.</p>
          <div id="loadingHint">Si tarda mucho, lo sustituiremos por otro.</div>
        </div>
      </div>
    </div>

    <script>
      window.__earlyQueue = [];
      window.addEventListener("message", (e) => {
        window.__earlyQueue.push(e.data);
      });
    </script>
    <script></script>

    <script type="module">
      import * as pdfjsLib from "./build/pdf.mjs";
      import { PDFViewer, EventBus } from "./web/pdf_viewer.mjs";

      pdfjsLib.GlobalWorkerOptions.workerSrc = "./build/pdf.worker.mjs";

      const params = new URLSearchParams(location.search);
      const url = params.get("file");
      if (!url) {
        document.body.innerHTML =
          '<p style="color:white;padding:16px">Falta el parámetro ?file=</p>';
        throw new Error("Missing file param");
      }

      const MAX_WAIT_MS = 7000;
      const FIXED_DELAY_MS = 3500;
      const loadingMask = document.getElementById("loadingMask");
      let valuesAppliedOnce = false;
      let maskRemoved = false;
      const removeMask = () => {
        if (maskRemoved) return;
        maskRemoved = true;
        loadingMask?.remove();
        viewer.currentScaleValue = "page-width";
      };

      function delayedRemoveMask() {
        if (maskRemoved) return;
        setTimeout(() => removeMask(), FIXED_DELAY_MS);
      }

      setTimeout(() => {
        if (!valuesAppliedOnce) removeMask();
      }, MAX_WAIT_MS);

      const eventBus = new EventBus();
      const container = document.getElementById("container");
      const viewer = new PDFViewer({
        container,
        eventBus,
        annotationMode: pdfjsLib.AnnotationMode.ENABLE_FORMS,
        textLayerMode: 2,
      });

      let pendingValues = null;
      let liveValues = {};
      // Track which pages have had initial values applied to avoid overwriting
      // user edits on re-render (e.g., zoom changes re-render annotation layers).
      let appliedValuePages = new Set(); // of page numbers (1-based)
      let readyForData = false;

      const AVATAR_ANNOTATION_ID = "108R";
      const AVATAR_DEFAULT_PLACEHOLDER = "";
      const avatarState = {
        enabled: false,
        src: "",
        fit: "cover",
        geom: null,
      };

      function findAnchorInLayer(layerDiv) {
        if (!layerDiv) return null;
        const sel = `[data-annotation-id="${CSS.escape(AVATAR_ANNOTATION_ID)}"]`;
        return layerDiv.querySelector(sel);
      }

      function measureBoxRelativeToLayer(anchorEl, layerDiv) {
        const ar = anchorEl.getBoundingClientRect();
        const lr = layerDiv.getBoundingClientRect();
        return {
          x: ar.left - lr.left,
          y: ar.top - lr.top,
          w: ar.width,
          h: ar.height,
        };
      }

      function ensureAvatarInsideAnchor(layerDiv) {
        try {
          if (!avatarState.enabled) return;
          if (!layerDiv) return;
          const anchor = findAnchorInLayer(layerDiv);
          if (!anchor) return;
          const pageDiv = layerDiv.closest?.(".page");
          if (!pageDiv) return;
          const pageIndex =
            parseInt(pageDiv.getAttribute("data-page-number"), 10) || 0;
          const box = measureBoxRelativeToLayer(anchor, layerDiv);
          const pw = pageDiv.clientWidth || pageDiv.offsetWidth || 1;
          const ph = pageDiv.clientHeight || pageDiv.offsetHeight || 1;
          avatarState.geom = {
            pageIndex,
            xNorm: box.x / pw,
            yNorm: box.y / ph,
            wNorm: box.w / pw,
            hNorm: box.h / ph,
          };

          const textarea = anchor.querySelector("textarea");
          if (textarea) textarea.remove();

          let img = anchor.querySelector("img.avatar-image-108R");
          if (!img) {
            img = document.createElement("img");
            img.className = "avatar-image-108R";
            img.alt = "Avatar";
            img.style.width = "100%";
            img.style.height = "100%";
            img.style.display = "block";
            img.style.objectFit = avatarState.fit || "cover";
            img.decoding = "async";
            img.style.background = "transparent";
            img.draggable = false;
            anchor.appendChild(img);
          }
          if (img.style.objectFit !== (avatarState.fit || "cover")) {
            img.style.objectFit = avatarState.fit || "cover";
          }
          const nextSrc = avatarState.enabled ? avatarState.src : "";
          if (img.getAttribute("src") !== nextSrc) {
            if (nextSrc) img.setAttribute("src", nextSrc);
            else img.removeAttribute("src");
          }
          // Make sure anchor is visible and interactive state is normal
          anchor.style.visibility = "visible";
          anchor.style.pointerEvents = "auto";
        } catch (e) {
          // noop
        }
      }

      function refreshAvatarEverywhere() {
        document.querySelectorAll(".annotationLayer").forEach((layer) => {
          ensureAvatarInsideAnchor(layer);
        });
      }

      function clearAvatarEverywhere() {
        const sel = `[data-annotation-id="${CSS.escape(AVATAR_ANNOTATION_ID)}"]`;
        document.querySelectorAll(sel).forEach((anchor) => {
          anchor
            .querySelectorAll("img.avatar-image-108R")
            .forEach((img) => img.remove());
        });
      }

      function inputsReady() {
        return (
          !!document.querySelector('input[name="CharacterName"]') ||
          document.querySelector("input, textarea, select")
        );
      }
      function deferUntilInputsReady(fn, tries = 80) {
        if (inputsReady()) {
          fn();
          return;
        }
        if (tries <= 0) {
          fn();
          return;
        }
        setTimeout(() => deferUntilInputsReady(fn, tries - 1), 100);
      }

      function applyPdfFormValues(values, root) {
        const scope = root || document.getElementById("container");
        const fields = scope.querySelectorAll("input, textarea, select");
        const byName = {};
        fields.forEach((el) => {
          const key =
            el.name ||
            el.getAttribute("data-annotation-id") ||
            el.getAttribute("aria-label") ||
            el.getAttribute("title");
          if (key) byName[key] = el;
        });
        for (const [k, v] of Object.entries(values)) {
          const el = byName[k];
          if (!el) continue;
          if (el.type === "checkbox") el.checked = !!v;
          else el.value = v ?? "";
          el.dispatchEvent(new Event("input", { bubbles: true }));
          el.dispatchEvent(new Event("change", { bubbles: true }));
        }
      }

      function attachValueTrackers(root) {
        const scope = root || document.getElementById("container");
        const fields = scope.querySelectorAll("input, textarea, select");
        fields.forEach((el) => {
          if (el.__valueTracked) return;
          const update = () => {
            const key =
              el.name ||
              el.getAttribute("data-annotation-id") ||
              el.getAttribute("aria-label") ||
              el.getAttribute("title");
            if (!key) return;
            if (el.type === "checkbox") liveValues[key] = !!el.checked;
            else liveValues[key] = el.value || "";
          };
          el.addEventListener("input", update, { passive: true });
          el.addEventListener("change", update, { passive: true });
          el.__valueTracked = true;
        });
      }

      function collectPdfFormValues() {
        const root = document.getElementById("container");
        const fields = root.querySelectorAll("input, textarea, select");
        const out = {};
        fields.forEach((el) => {
          const key =
            el.name ||
            el.getAttribute("data-annotation-id") ||
            el.getAttribute("aria-label") ||
            el.getAttribute("title");
          if (!key) return;
          if (el.type === "checkbox") out[key] = !!el.checked;
          else out[key] = el.value || "";
        });
        return out;
      }

      function warmupPages() {
        const c = document.getElementById("container");
        const y = c.scrollTop;
        c.scrollTop = c.scrollHeight;
        setTimeout(() => {
          c.scrollTop = 0;
        }, 50);
        setTimeout(() => {
          c.scrollTop = y;
        }, 100);
      }

      function postReady() {
        if (readyForData) return;
        readyForData = true;
        try {
          window.parent?.postMessage({ type: "VIEWER_READY" }, "*");
        } catch {}
        try {
          const q = window.__earlyQueue || [];
          q.forEach((d) => handleIncoming(d));
          window.__earlyQueue = [];
        } catch {}
      }

      eventBus.on("annotationlayerrendered", (evt) => {
        ensureCalculatedFieldsVisible();
        attachRecomputeListeners();
        setTimeout(() => {
          ensureCalculatedFieldsVisible();
          recompute();
        }, 0);
        try {
          const layerDiv = evt?.source?.div || evt?.source?.annotationLayer?.div || null;
          if (layerDiv) {
            attachValueTrackers(layerDiv);
            const valuesToApply = Object.keys(liveValues || {}).length
              ? liveValues
              : pendingValues;
            if (valuesToApply) applyPdfFormValues(valuesToApply, layerDiv);
          }
        } catch {}
        // Place/update avatar overlay when the annotation layer of a page is ready
        try {
          const layerDiv =
            evt?.source?.div || evt?.source?.annotationLayer?.div || null;
          if (layerDiv) ensureAvatarInsideAnchor(layerDiv);
        } catch {}
        // Place/update header image on first page
        try {
          const layerDiv =
            evt?.source?.div || evt?.source?.annotationLayer?.div || null;
          if (layerDiv) ensureHeaderOnLayer(layerDiv);
        } catch {}
        postReady();
      });

      const loadingTask = pdfjsLib.getDocument({
        url,
        cMapUrl: "./cmaps/",
        cMapPacked: true,
      });
      let pdf = await loadingTask.promise;
      viewer.setDocument(pdf);

      container.addEventListener("pagesinit", () => {
        viewer.currentScaleValue = "page-width";
        setTimeout(() => {
          ensureCalculatedFieldsVisible();
          attachRecomputeListeners();
          recompute();
        }, 250);
        // Try to ensure avatar appears even if the event timing differs (solo si está habilitado)
        try {
          let tries = 60;
          const tick = () => {
            if (avatarState.enabled) ensureAvatarAnywhere();
            if (avatarState.enabled) ensureHeaderAnywhere();
            if (
              avatarState.enabled &&
              --tries > 0 &&
              !document.querySelector(
                'section[data-annotation-id="108R"] img.avatar-image-108R',
              )
            ) {
              setTimeout(tick, 200);
            }
          };
          tick();
        } catch {}
        postReady();
      });

      function handleIncoming(data) {
        if (!data || typeof data.type !== "string") return;
        switch (data.type) {
          case "ZOOM_IN":
            viewer.currentScale *= 1.1;
            break;
          case "ZOOM_OUT":
            viewer.currentScale /= 1.1;
            break;
          case "FIT_WIDTH":
            viewer.currentScaleValue = "page-width";
            break;
          case "FIT_PAGE":
            viewer.currentScaleValue = "page-fit";
            break;
          case "PRINT_PDF":
            (async () => {
              try {
                const values = collectPdfFormValues();
                let originalBytes;
                try {
                  const data = await pdf.getData();
                  originalBytes =
                    data instanceof Uint8Array ? data : new Uint8Array(data);
                } catch {
                  const res = await fetch(url, { credentials: "include" });
                  if (!res.ok) throw new Error(`HTTP ${res.status}`);
                  originalBytes = new Uint8Array(await res.arrayBuffer());
                }
                let PDFDocument, PDFName, PDFBool;
                try {
                  const mod = await import(
                    "https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/+esm"
                  );
                  PDFDocument = mod.PDFDocument;
                  PDFName = mod.PDFName;
                  PDFBool = mod.PDFBool;
                } catch {
                  await new Promise((resolve, reject) => {
                    const s = document.createElement("script");
                    s.src =
                      "https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js";
                    s.onload = resolve;
                    s.onerror = reject;
                    document.head.appendChild(s);
                  });
                  const mod = window.PDFLib;
                  PDFDocument = mod.PDFDocument;
                  PDFName = mod.PDFName;
                  PDFBool = mod.PDFBool;
                }
                const pdfDoc = await PDFDocument.load(originalBytes, {
                  updateMetadata: false,
                  ignoreEncryption: true,
                });
                const form = pdfDoc.getForm();
                for (const [k, v] of Object.entries(values)) {
                  let field;
                  try {
                    field = form.getField(k);
                  } catch {}
                  if (!field) continue;
                  const t = field.constructor.name;
                  if (t === "PDFTextField") field.setText(String(v ?? ""));
                  else if (t === "PDFCheckBox")
                    v ? field.check() : field.uncheck();
                  else if (t === "PDFDropdown") {
                    try {
                      field.select(String(v));
                    } catch {
                      field.setText(String(v ?? ""));
                    }
                  } else if (t === "PDFOptionList") {
                    try {
                      field.select(String(v));
                    } catch {}
                  } else if (t === "PDFRadioGroup") {
                    try {
                      field.select(String(v));
                    } catch {}
                  } else {
                    try {
                      field.setText(String(v ?? ""));
                    } catch {}
                  }
                }
                try {
                  const acroFormRef = pdfDoc.catalog.get(
                    PDFName.of("AcroForm"),
                  );
                  if (acroFormRef) {
                    const acroForm = pdfDoc.context.lookup(acroFormRef);
                    acroForm.set(PDFName.of("NeedAppearances"), PDFBool.True);
                  }
                } catch {}
                const out = await pdfDoc.save({
                  addDefaultPage: false,
                  useObjectStreams: true,
                });
                const blob = new Blob([out], { type: "application/pdf" });
                const urlFilled = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = urlFilled;
                a.download = values.CharacterName
                  ? `Ficha_${values.CharacterName.replace(/[\/\\?%*:|"<>]/g, "_")}.pdf`
                  : "Ficha.pdf";
                document.body.appendChild(a);
                a.click();
                a.remove();
                setTimeout(() => URL.revokeObjectURL(urlFilled), 4000);
              } catch (ex) {
                console.error(ex);
                window.print();
              }
            })();
            break;
          case "SET_PDF_FIELDS":
            deferUntilInputsReady(() => {
              pendingValues = data.values || {};
              // New incoming baseline values; allow one-time apply per page
              appliedValuePages = new Set();
              applyPdfFormValues(pendingValues);
              ensureCalculatedFieldsVisible();
              attachRecomputeListeners();
              recompute();
              valuesAppliedOnce = true;
              delayedRemoveMask();
              warmupPages();
            });
            break;
          case "SET_AVATAR": {
            const src = data?.src;
            const fit = data?.fit;
            if (typeof src === "string" && src) avatarState.src = src;
            if (fit === "cover" || fit === "contain") avatarState.fit = fit;
            avatarState.enabled = true;
            refreshAvatarEverywhere();
            setTimeout(() => ensureAvatarAnywhere(), 750);
            try {
              maybePrependCoverPageWithImage(avatarState.src);
            } catch {}
            break;
          }
          case "CLEAR_AVATAR": {
            avatarState.enabled = false;
            clearAvatarEverywhere();
            // Reload original PDF (without cover) and reapply values
            (async () => {
              try {
                // Mantain scale
                const lastScale = viewer.currentScale;
                let currentValues = {};
                try {
                  currentValues = collectPdfFormValues();
                } catch {}
                const newTask = pdfjsLib.getDocument({
                  url,
                  cMapUrl: "./cmaps/",
                  cMapPacked: true,
                });
                const newPdf = await newTask.promise;
                pdf = newPdf;
                viewer.setDocument(newPdf);
                pendingValues = currentValues || {};
                // allow layers to mount before applying
                viewer.currentScale = lastScale;
                setTimeout(() => {
                  try {
                    applyPdfFormValues(pendingValues);
                  } catch {}
                }, 600);
                // allow future cover reinsertion for a new avatar
                try {
                  __coverInjectedFor = null;
                } catch {}
              } catch {}
            })();
            break;
          }
          case "SET_HEADER_IMAGE": {
            const src = data?.src;
            const fit = data?.fit;
            const heightRatio = Number(data?.heightRatio);
            if (typeof src === "string" && src) headerState.src = src;
            if (fit === "cover" || fit === "contain") headerState.fit = fit;
            if (
              !Number.isNaN(heightRatio) &&
              heightRatio > 0 &&
              heightRatio < 1
            ) {
              headerState.heightRatio = heightRatio;
            }
            headerState.enabled = true;
            setTimeout(() => ensureHeaderAnywhere(), 50);
            setTimeout(() => ensureHeaderAnywhere(), 250);
            setTimeout(() => ensureHeaderAnywhere(), 750);
            break;
          }
          case "CLEAR_HEADER_IMAGE": {
            headerState.enabled = false;
            clearHeaderEverywhere();
            break;
          }
        }
      }

      // Ensure avatar injection without relying solely on event timing
      function ensureAvatarAnywhere() {
        const anchors = document.querySelectorAll(
          `section[data-annotation-id="${CSS.escape(AVATAR_ANNOTATION_ID)}"]`,
        );
        anchors.forEach((anchor) => {
          const layerDiv = anchor.closest(".annotationLayer");
          ensureAvatarInsideAnchor(layerDiv);
        });
      }

      // Build a new PDF in-memory by prepending a cover page with the given image,
      // then reload the viewer to show it as the first page.
      let __coverInjectedFor = null;
      async function maybePrependCoverPageWithImage(imgSrc) {
        try {
          if (!imgSrc || __coverInjectedFor === imgSrc) return;
          // Capture current form values to re-apply after reload
          let currentValues = {};
          try {
            currentValues = collectPdfFormValues();
          } catch {}

          // Get original bytes
          let originalBytes;
          try {
            const data = await pdf.getData();
            originalBytes =
              data instanceof Uint8Array ? data : new Uint8Array(data);
          } catch {
            const res = await fetch(url, { credentials: "include" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            originalBytes = new Uint8Array(await res.arrayBuffer());
          }

          // Load pdf-lib
          let PDFDocument;
          try {
            const mod = await import(
              "https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/+esm"
            );
            PDFDocument = mod.PDFDocument;
          } catch {
            await new Promise((resolve, reject) => {
              const s = document.createElement("script");
              s.src =
                "https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js";
              s.onload = resolve;
              s.onerror = reject;
              document.head.appendChild(s);
            });
            PDFDocument = window.PDFLib.PDFDocument;
          }

          const pdfDoc = await PDFDocument.load(originalBytes, {
            updateMetadata: false,
            ignoreEncryption: true,
          });
          const pages = pdfDoc.getPages();
          const baseW = pages[0]?.getWidth?.() || 595;
          const baseH = pages[0]?.getHeight?.() || 842;
          const cover = pdfDoc.insertPage(0, [baseW, baseH]);

          // Fetch image bytes
          const imgRes = await fetch(imgSrc, { credentials: "omit" });
          const imgBuf = await imgRes.arrayBuffer();
          const bytesU8 = new Uint8Array(imgBuf);
          let embedded;
          try {
            embedded = await pdfDoc.embedJpg(bytesU8);
          } catch {
            embedded = await pdfDoc.embedPng(bytesU8);
          }
          const imgW = embedded.width,
            imgH = embedded.height;
          const scale = Math.min(baseW / imgW, baseH / imgH);
          const drawW = imgW * scale,
            drawH = imgH * scale;
          const x = (baseW - drawW) / 2;
          const y = (baseH - drawH) / 2;
          cover.drawImage(embedded, { x, y, width: drawW, height: drawH });

          const out = await pdfDoc.save({
            addDefaultPage: false,
            useObjectStreams: true,
          });

          // Reload viewer with new bytes
          const newTask = pdfjsLib.getDocument({
            data: out,
            cMapUrl: "./cmaps/",
            cMapPacked: true,
          });
          const newPdf = await newTask.promise;
          pdf = newPdf;
          viewer.setDocument(newPdf);
          __coverInjectedFor = imgSrc;

          // Re-apply values after reload
          pendingValues = currentValues || {};
          setTimeout(() => {
            try {
              applyPdfFormValues(pendingValues);
            } catch {}
          }, 600);
        } catch (e) {
          // ignore
        }
      }

      // Header placement helpers (first page, top)
      function ensureHeaderOnLayer(layerDiv) {
        try {
          if (!layerDiv) return;
          const pageDiv = layerDiv.closest?.(".page");
          if (!pageDiv) return;
          const pageIndex =
            parseInt(pageDiv.getAttribute("data-page-number"), 10) || 0;
          if (pageIndex !== 1) return;
          if (!avatarState.enabled || !avatarState.src) return;

          const topImage = document.createElement("img");
          img.alt = "Header Image";
          img.className = "header-image-top";
          img.style.width = "100%";
          img.style.height = "100%";
          img.style.objectFit = avatarState.fit || "cover";
          img.decoding = "async";
          img.setAttribute("draggable", "false");
          img.style.userSelect = "none";
          img.style.webkitUserDrag = "none";
          layerDiv.appendChild(topImage);

          const pw = pageDiv.clientWidth || pageDiv.offsetWidth || 1;
          const ph = pageDiv.clientHeight || pageDiv.offsetHeight || 1;
          const h = Math.max(1, Math.round(ph * 0.12));
          overlay.style.width = `${pw}px`;
          overlay.style.height = `${h}px`;

          const img = overlay.querySelector("img.header-image-top");
          if (img) {
            if (img.style.objectFit !== (avatarState.fit || "cover")) {
              img.style.objectFit = avatarState.fit || "cover";
            }
            const nextSrc = avatarState.enabled ? avatarState.src : "";
            if (img.getAttribute("src") !== nextSrc) {
              if (nextSrc) img.setAttribute("src", nextSrc);
              else img.removeAttribute("src");
            }
          }
        } catch {}
      }

      function ensureHeaderAnywhere() {
        document.querySelectorAll(".annotationLayer").forEach((layer) => {
          ensureHeaderOnLayer(layer);
        });
      }

      function clearHeaderEverywhere() {
        document
          .querySelectorAll(".annotationLayer div.headerOverlayTop")
          .forEach((el) => el.remove());
      }

      window.addEventListener("message", (e) => handleIncoming(e.data));

      window.addEventListener("message", (ev) => {
        if (!ev.data || ev.data.type !== "GET_PDF_FIELDS") return;
        const values = collectPdfFormValues();
        ev.source?.postMessage({ type: "PDF_FIELDS", values }, ev.origin);
      });

      function parseIntSafe(v) {
        if (v === null || v === undefined) return NaN;
        const s = String(v).trim();
        const m = s.match(/^[+\-]?\d+/);
        return m ? parseInt(m[0], 10) : NaN;
      }
      function abilityMod(scoreVal) {
        const n = parseIntSafe(scoreVal);
        if (Number.isNaN(n)) return null;
        return Math.floor((n - 10) / 2);
      }
      function formatSigned(n) {
        if (n === null || n === undefined || Number.isNaN(n)) return "";
        return n >= 0 ? `+${n}` : `${n}`;
      }
      function getEl(name) {
        return document.querySelector(`[name="${CSS.escape(name)}"]`);
      }
      function getValue(name) {
        const el = getEl(name);
        if (!el) return "";
        return el.type === "checkbox" ? (el.checked ? "Yes" : "") : el.value;
      }
      function getChecked(name) {
        const el = getEl(name);
        return !!(el && el.type === "checkbox" && el.checked);
      }
      function setValue(name, val) {
        const el = getEl(name);
        if (!el) return;
        el.value =
          val === "" || val === null || val === undefined ? "" : String(val);
      }
      function ensureVisible(name) {
        const el = getEl(name);
        if (!el) return;
        el.hidden = false;
        el.disabled = false;
        el.removeAttribute("hidden");
        el.style.display = "block";
        el.style.visibility = "visible";
        el.readOnly = false;
      }

      const abilityBonusFields = [
        "STRbonus",
        "DEXbonus",
        "CONbonus",
        "INTbonus",
        "WISbonus",
        "CHAbonus",
      ];
      const saveTotalFields = [
        "STRsave",
        "DEXsave",
        "CONsave",
        "INTsave",
        "WISsave",
        "CHAsave",
      ];
      const skillOutFields = [
        "Acrobatics",
        "Athletics",
        "Deception",
        "History",
        "Performance",
        "Intimidation",
        "Investigation",
        "SleightofHand",
        "Arcana",
        "Medicine",
        "Nature",
        "Perception",
        "Insight",
        "Persuasion",
        "Religion",
        "Stealth",
        "Survival",
        "AnHan",
      ];

      function ensureCalculatedFieldsVisible() {
        [
          ...abilityBonusFields,
          ...saveTotalFields,
          ...skillOutFields,
          "PWP",
        ].forEach(ensureVisible);
      }

      function attachRecomputeListeners() {
        const namesToWatch = [
          "STRscore",
          "DEXscore",
          "CONscore",
          "INTscore",
          "WISscore",
          "CHAscore",
          "ProfBonus",
          "STRsavePROF",
          "DEXsavePROF",
          "CONsavePROF",
          "INTsavePROF",
          "WISsavePROF",
          "CHAsavePROF",
          "acroPROF",
          "athPROF",
          "decepPROF",
          "histPROF",
          "perfPROF",
          "intimPROF",
          "investPROF",
          "sohPROF",
          "arcanaPROF",
          "medPROF",
          "naturePROF",
          "perPROF",
          "insightPROF",
          "persPROF",
          "religPROF",
          "stealthPROF",
          "survPROF",
          "anhanPROF",
        ];
        const sel = namesToWatch
          .map((n) => `[name="${CSS.escape(n)}"]`)
          .join(",");
        document.querySelectorAll(sel).forEach((el) => {
          if (el.__recomputeHooked) return;
          el.addEventListener("input", recompute, { passive: true });
          el.addEventListener("change", recompute, { passive: true });
          el.__recomputeHooked = true;
        });
      }

      function recompute() {
        ensureCalculatedFieldsVisible();
        const mods = {
          STR: abilityMod(getValue("STRscore")),
          DEX: abilityMod(getValue("DEXscore")),
          CON: abilityMod(getValue("CONscore")),
          INT: abilityMod(getValue("INTscore")),
          WIS: abilityMod(getValue("WISscore")),
          CHA: abilityMod(getValue("CHAscore")),
        };
        setValue("STRbonus", formatSigned(mods.STR ?? ""));
        setValue("DEXbonus", formatSigned(mods.DEX ?? ""));
        setValue("CONbonus", formatSigned(mods.CON ?? ""));
        setValue("INTbonus", formatSigned(mods.INT ?? ""));
        setValue("WISbonus", formatSigned(mods.WIS ?? ""));
        setValue("CHAbonus", formatSigned(mods.CHA ?? ""));
        const profBonus = parseIntSafe(getValue("ProfBonus")) || 0;
        [
          { out: "STRsave", mod: mods.STR, profBox: "STRsavePROF" },
          { out: "DEXsave", mod: mods.DEX, profBox: "DEXsavePROF" },
          { out: "CONsave", mod: mods.CON, profBox: "CONsavePROF" },
          { out: "INTsave", mod: mods.INT, profBox: "INTsavePROF" },
          { out: "WISsave", mod: mods.WIS, profBox: "WISsavePROF" },
          { out: "CHAsave", mod: mods.CHA, profBox: "CHAsavePROF" },
        ].forEach(({ out, mod, profBox }) => {
          if (mod === null) {
            setValue(out, "");
            return;
          }
          const total = mod + (getChecked(profBox) ? profBonus : 0);
          setValue(out, formatSigned(total));
        });
        const skillDefs = {
          Acrobatics: { mod: "DEX", prof: "acroPROF" },
          Athletics: { mod: "STR", prof: "athPROF" },
          Deception: { mod: "CHA", prof: "decepPROF" },
          History: { mod: "INT", prof: "histPROF" },
          Performance: { mod: "CHA", prof: "perfPROF" },
          Intimidation: { mod: "CHA", prof: "intimPROF" },
          Investigation: { mod: "INT", prof: "investPROF" },
          SleightofHand: { mod: "DEX", prof: "sohPROF" },
          Arcana: { mod: "INT", prof: "arcanaPROF" },
          Medicine: { mod: "WIS", prof: "medPROF" },
          Nature: { mod: "INT", prof: "naturePROF" },
          Perception: { mod: "WIS", prof: "perPROF" },
          Insight: { mod: "WIS", prof: "insightPROF" },
          Persuasion: { mod: "CHA", prof: "persPROF" },
          Religion: { mod: "INT", prof: "religPROF" },
          Stealth: { mod: "DEX", prof: "stealthPROF" },
          Survival: { mod: "WIS", prof: "survPROF" },
          AnHan: { mod: "WIS", prof: "anhanPROF" },
        };
        Object.entries(skillDefs).forEach(([out, { mod, prof }]) => {
          const m = mods[mod];
          if (m === null) {
            setValue(out, "");
            return;
          }
          const total = m + (getChecked(prof) ? profBonus : 0);
          setValue(out, formatSigned(total));
        });
        if (mods.WIS !== null) {
          const passive =
            10 + mods.WIS + (getChecked("perPROF") ? profBonus : 0);
          setValue("PWP", String(passive));
        } else {
          setValue("PWP", "");
        }
      }
    </script>
  </body>
</html>
